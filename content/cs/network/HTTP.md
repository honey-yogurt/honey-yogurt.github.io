+++
title = 'HTTP'
date = 2024-04-02T14:14:48+08:00
+++

## HTTP 基本概念
HTTP 是超文本传输协议，也就是HyperText Transfer Protocol。

HTTP 是一个在计算机世界里专门在「两点」之间「传输」文字、图片、音频、视频等「超文本」数据的「约定和规范」。
> 两点：服务器—浏览器；服务器-服务器等

## HTTP 常见的状态码有哪些
{{% details title="展开图片" closed="true" %}}
![img.png](/images/cs/network/HTTP-1.png)
{{% /details %}}
1xx 类状态码属于**提示信息**，是协议处理中的一种**中间状态**，实际用到的比较少。

2xx 类状态码表示服务器**成功**处理了客户端的请求，也是我们最愿意看到的状态。
+ 「200 OK」是最常见的成功状态码，表示一切正常。如果是非 HEAD 请求，服务器返回的响应头都会有 body 数据。 
+ 「204 No Content」也是常见的成功状态码，与 200 OK 基本相同，但**响应头没有 body 数据**。 
+ 「206 Partial Content」是应用于 HTTP **分块下载或断点续传**，表示响应返回的 body 数据**并不是资源的全部**，而是其中的一部分，也是服务器处理成功的状态。

3xx 类状态码表示客户端请求的**资源发生了变动**，需要**客户端用新的 URL 重新发送请求**获取资源，也就是**重定向**。
+ 「301 Moved Permanently」表示**永久重定向**，说明请求的资源已经不存在了，需改用新的 URL 再次访问。 
+ 「302 Found」表示**临时重定向**，说明请求的资源还在，但暂时需要用另一个 URL 来访问。

301 和 302 都会在响应头里使用字段 Location，指明后续要跳转的 URL，浏览器会自动重定向新的 URL。
+ 「304 Not Modified」不具有跳转的含义，表示资源未修改，**重定向已存在的缓冲文件，也称缓存重定向，也就是告诉客户端可以继续使用缓存资源**，用于缓存控制。

4xx 类状态码表示客户端发送的**报文有误**，服务器无法处理，也就是错误码的含义。
+ 「400 Bad Request」表示客户端请求的报文有错误，但只是个笼统的错误。 
+ 「403 Forbidden」表示**服务器禁止访问资源**，并不是客户端的请求出错。 
+ 「404 Not Found」表示请求的资源在服务器上**不存在或未找到**，所以无法提供给客户端。

5xx 类状态码表示客户端请求报文正确，但是**服务器处理时内部发生了错误**，属于服务器端的错误码。
+ 「500 Internal Server Error」与 400 类型，是个笼统通用的错误码，服务器发生了什么错误，我们并不知道。 
+ 「501 Not Implemented」表示客户端请求的功能还不支持，类似“即将开业，敬请期待”的意思。 
+ 「502 Bad Gateway」通常是**服务器作为网关或代理时**返回的错误码，表示服务器自身工作正常，访问后端服务器发生了错误。 
+ 「503 Service Unavailable」表示服务器当前很忙，暂时无法响应客户端，类似“网络服务正忙，请稍后重试”的意思。

## HTTP 常见字段有哪些
+ Host 字段: 客户端发送请求时，用来指定服务器的域名。 
+ Content-Length 字段: **服务器**在返回数据时，会有 Content-Length 字段，表明本次回应的**数据长度**。

大家应该都知道 HTTP 是基于 TCP 传输协议进行通信的，而使用了 TCP 传输协议，就会存在一个“粘包”的问题，HTTP 协议通过设置**回车符、换行符作为 HTTP header 的边界**，通过 **Content-Length 字段作为 HTTP body 的边界**，这两个方式都是为了解决“粘包”的问题。

+ Connection 字段: Connection 字段最常用于**客户端要求服务器使用「HTTP 长连接」机制**，以便其他请求**复用**。

HTTP 长连接的特点是，只要任意一端没有明确提出断开连接，则保持 TCP 连接状态。

HTTP/1.1 版本的默认连接都是长连接，但为了兼容老版本的 HTTP，需要指定 Connection 首部字段的值为 Keep-Alive。

+ Content-Type 字段: Content-Type 字段用于**服务器回应**时，告诉客户端，本次**数据是什么格式**。

```text
Content-Type: text/html; Charset=utf-8
```
上面的类型表明，发送的是网页，而且编码是UTF-8。

**客户端请求**的时候，可以使用 **Accept** 字段声明自己**可以接受哪些数据格式**。
```text
Accept: */*
```
上面代码中，客户端声明自己可以接受任何格式的数据。

+ Content-Encoding 字段: Content-Encoding 字段说明数据的压缩方法。表示**服务器返回的数据使用了什么压缩格式。**

客户端在请求时，用 **Accept-Encoding** 字段说明自己可以接受哪些压缩方法。

## GET 与 POST
### GET 和 POST 有什么区别？
根据 RFC 规范，**GET 的语义是从服务器获取指定的资源**，这个资源可以是静态的文本、页面、图片视频等。GET 请求的**参数位置一般是写在 URL 中**，URL 规定只能支持 **ASCII**，所以 GET 请求的参数只允许 ASCII 字符 ，而且**浏览器会对 URL 的长度有限制**（HTTP协议本身对 URL长度并没有做任何规定）。

根据 RFC 规范，**POST 的语义是根据请求负荷（报文body）对指定的资源做出处理**，具体的处理方式视资源类型而不同。POST 请求携带数据的位置一般是写在**报文 body 中**，body 中的数据可以是任意格式的数据，只要客户端与服务端协商好即可，而且浏览器不会对 body 大小做限制。

### GET 和 POST 方法都是安全和幂等的吗？
先说明下安全和幂等的概念：
+ 在 HTTP 协议里，所谓的「安全」是指请求方法不会「破坏」服务器上的资源。 
+ 所谓的「幂等」，意思是多次执行相同的操作，结果都是「相同」的。

如果从 RFC 规范定义的语义来看：
+ **GET 方法就是安全且幂等的**，因为它是「只读」操作，无论操作多少次，服务器上的数据都是安全的，且每次的结果都是相同的。所以，可以**对 GET 请求的数据做缓存**，这个缓存可以做到浏览器本身上（彻底避免浏览器发请求），也可以做到代理上（如nginx），而且在浏览器中 GET 请求可以保存为书签。 
+ POST 因为是「新增或提交数据」的操作，会**修改服务器上的资源，所以是不安全的，且多次提交数据就会创建多个资源，所以不是幂等的**。所以，**浏览器一般不会缓存 POST 请求**，也不能把 POST 请求保存为书签。

> Q: GET 请求可以带 body 吗？
> 
> A: RFC 规范并没有规定 GET 请求不能带 body 的。理论上，任何请求都可以带 body 的。只是因为 RFC 规范定义的 GET 请求是获取资源，所以根据这个语义不需要用到 body。
> 
> 另外，URL 中的查询参数也不是 GET 所独有的，POST 请求的 URL 中也可以有参数的。

## HTTP 缓存技术
对于一些具有重复性的 HTTP 请求，比如每次请求得到的数据都一样的，我们可以把这对「请求-响应」的数据都**缓存在本地**，那么下次就直接读取本地的数据，不必在通过网络获取服务器的响应了，这样的话 HTTP/1.1 的性能肯定肉眼可见的提升。

### 强制缓存
**强缓存指的是只要浏览器判断缓存没有过期，则直接使用浏览器的本地缓存，决定是否使用缓存的主动性在于浏览器这边。**

如下图中，返回的是 200 状态码，但在 size 项中标识的是 from disk cache，就是使用了强制缓存。
{{% details title="展开图片" closed="true" %}}
![img.png](/images/cs/network/HTTP-2.png)
{{% /details %}}

强缓存是利用下面这两个 HTTP **响应头部**（Response Header）字段实现的，它们都用来表示资源在**客户端缓存的有效期**：
+ Cache-Control， 是一个相对时间；
+ Expires，是一个绝对时间；

如果 HTTP 响应头部同时有 Cache-Control 和 Expires 字段的话，**Cache-Control 的优先级高于 Expires** 。

Cache-control 选项更多一些，设置更加精细，所以建议使用 Cache-Control 来实现强缓存。具体的实现流程如下：

+ 当浏览器第一次请求访问服务器资源时，服务器会在返回这个资源的同时，在 Response 头部加上 Cache-Control，Cache-Control 中设置了过期时间大小； 
+ 浏览器再次请求访问服务器中的该资源时，会**先通过请求资源的时间与 Cache-Control 中设置的过期时间大小，来计算出该资源是否过期**，如果没有，则使用该缓存，否则重新请求服务器； 
+ 服务器再次收到请求后，会再次更新 Response 头部的 Cache-Control。

### 协商缓存
当我们在浏览器使用开发者工具的时候，你可能会看到过某些请求的**响应码是 304**，这个是告诉浏览器可以**使用本地缓存的资源**，通常这种通过服务端告知客户端是否可以使用缓存的方式被称为协商缓存。
{{% details title="展开图片" closed="true" %}}
![img.png](/images/cs/network/HTTP-3.png)
{{% /details %}}
上图就是一个协商缓存的过程，所以**协商缓存就是与服务端协商之后，通过协商结果来判断是否使用本地缓存**。

协商缓存可以基于两种头部来实现。

第一种：请求头部中的 If-Modified-Since 字段与响应头部中的 Last-Modified 字段实现，这两个字段的意思是：
+ 响应头部中的 Last-Modified：标示这个响应资源的最后修改时间； 
+ 请求头部中的 If-Modified-Since：当资源过期了，发现响应头中具有 Last-Modified 声明，则再次发起请求的时候带上 Last-Modified 的时间，服务器收到请求后发现有 If-Modified-Since 则与被请求资源的最后修改时间进行对比（Last-Modified），如果最后修改时间较新（大），说明资源又被改过，则返回最新资源，HTTP 200 OK；如果最后修改时间较旧（小），说明资源无新修改，响应 HTTP 304 走缓存。

第二种：请求头部中的 If-None-Match 字段与响应头部中的 ETag 字段，这两个字段的意思是：
+ 响应头部中 Etag：唯一标识响应资源； 
+ 请求头部中的 If-None-Match：当资源过期时，浏览器发现响应头里有 Etag，则再次向服务器发起请求时，会将请求头 If-None-Match 值设置为 Etag 的值。服务器收到请求后进行比对，如果资源没有变化返回 304，如果资源变化了返回 200。

第一种实现方式是基于时间实现的，第二种实现方式是**基于一个唯一标识实现**的，相对来说后者可以**更加准确地判断文件内容是否被修改，避免由于时间篡改导致的不可靠问题**。

如果在第一次请求资源的时候，服务端返回的 HTTP 响应头部同时有 Etag 和 Last-Modified 字段，那么客户端再下一次请求的时候，如果带上了 ETag 和 Last-Modified 字段信息给服务端，这时 **Etag 的优先级更高**，也就是服务端先会判断 Etag 是否变化了，如果 Etag 有变化就不用在判断 Last-Modified 了，如果 Etag 没有变化，然后再看 Last-Modified。

**为什么 ETag 的优先级更高**？这是因为 ETag 主要能解决 Last-Modified 几个比较难以解决的问题：
+ 在没有修改文件内容情况下文件的最后修改时间可能也会改变，这会导致客户端认为这文件被改动了，从而重新请求； 
+ 可能有些文件是在秒级以内修改的，If-Modified-Since 能检查到的粒度是秒级的，使用 Etag就能够保证这种需求下客户端在 1 秒内能刷新多次； 
+ 有些服务器不能精确获取文件的最后修改时间。
  
注意，**协商缓存这两个字段都需要配合强制缓存中 Cache-Control 字段来使用，只有在未能命中强制缓存的时候，才能发起带有协商缓存字段的请求**。
{{% details title="展开图片" closed="true" %}}
![img.png](/images/cs/network/HTTP-4.png)
{{% /details %}}

当使用 ETag 字段实现的协商缓存的过程：

+ 当浏览器第一次请求访问服务器资源时，服务器会在返回这个资源的同时，在 Response 头部加上 ETag 唯一标识，这个唯一标识的值是根据当前请求的资源生成的； 
+ 当浏览器再次请求访问服务器中的该资源时，首先会先检查强制缓存是否过期： 
  + 如果没有过期，则直接使用本地缓存； 
  + 如果缓存过期了，会在 Request 头部加上 If-None-Match 字段，该字段的值就是 ETag 唯一标识； 
+ 服务器再次收到请求后，**会根据请求中的 If-None-Match 值与当前请求的资源生成的唯一标识进行比较**： 
  + **如果值相等，则返回 304 Not Modified，不会返回资源**； 
  + 如果不相等，则返回 200 状态码和返回资源，并在 Response 头部加上新的 ETag 唯一标识；
+ 如果浏览器收到 304 的请求响应状态码，则会从本地缓存中加载资源，否则更新资源。

## HTTP 特性
### HTTP/1.1 的优点
简单：HTTP 基本的报文格式就是 header + body，头部信息也是 key-value 简单文本的形式，易于理解，降低了学习和使用的门槛。

灵活和易于扩展：HTTP 协议里的各类请求方法、URI/URL、状态码、头字段等每个组成要求都没有被固定死，都允许开发人员**自定义和扩充**。同时 HTTP 由于是工作在应用层（ OSI 第七层），则它**下层可以随意变化**。比如：HTTPS 就是在 HTTP 与 TCP 层之间增加了 SSL/TLS 安全传输层；HTTP/1.1 和 HTTP/2.0 传输协议使用的是 TCP 协议，而到了 HTTP/3.0 传输协议改用了 UDP 协议。

应用广泛和跨平台

### HTTP/1.1 的缺点有哪些
无状态双刃剑。

无状态的好处，因为服务器不会去记忆 HTTP 的状态，所以不需要额外的资源来记录状态信息，这能**减轻服务器的负担**，能够把更多的 CPU 和内存用来对外提供服务。

无状态的坏处，既然服务器没有记忆能力，它在完成有关联性的操作时会非常麻烦。

例如登录->添加购物车->下单->结算->支付，这系列操作都要知道用户的身份才行。但服务器不知道这些请求是有关联的，每次都要问一遍身份信息。

Cookie 通过在**请求和响应报文**中写入 Cookie 信息来控制**客户端的状态**。

相当于，**在客户端第一次请求后，服务器会下发一个装有客户信息的「小贴纸」，后续客户端请求服务器的时候，带上「小贴纸」，服务器就能认得了了**。
{{% details title="展开图片" closed="true" %}}
![img.png](/images/cs/network/HTTP-5.png)
{{% /details %}}

明文传输双刃剑。

明文意味着在传输过程中的信息，是可方便阅读的，比如 Wireshark 抓包都可以直接肉眼查看，为我们调试工作带了极大的便利性。

但是这正是这样，HTTP 的所有信息都暴露在了光天化日下，相当于信息裸奔。在传输的漫长的过程中，信息的内容都毫无隐私可言，很容易就能被窃取，如果里面有你的账号密码信息，那你号没了。

不安全。

HTTP 比较严重的缺点就是不安全：

+ 通信使用**明文**（不加密），内容可能会被窃听。比如，账号信息容易泄漏，那你号没了。 
+ **不验证通信方的身份**，因此有可能遭遇伪装。比如，访问假的淘宝、拼多多，那你钱没了。 
+ **无法证明报文的完整性**，所以有可能已遭篡改。比如，网页上植入垃圾广告，视觉污染，眼没了。 

HTTP 的安全问题，可以用 HTTPS 的方式解决，也就是通过引入 SSL/TLS 层，使得在安全上达到了极致。

### HTTP/1.1 的性能如何
长连接

HTTP 协议是基于 **TCP/IP**，并且使用了「**请求 - 应答**」的通信模式，所以性能的关键就在这两点里。

早期 HTTP/1.0 性能上的一个很大的问题，那就是每发起一个请求，都要新建一次 TCP 连接（三次握手），而且是串行请求，做了无谓的 TCP 连接建立和断开，增加了通信开销。

为了解决上述 TCP 连接问题，HTTP/1.1 提出了长连接的通信方式，也叫持久连接。这种方式的好处在于减少了 TCP 连接的重复建立和断开所造成的额外开销，减轻了服务器端的负载。

持久连接的特点是，只要任意一端没有明确提出断开连接，则保持 TCP 连接状态。

当然，如果某个 HTTP 长连接**超过一定时间没有任何数据交互**，**服务端**就会主动断开这个连接。

管道网络传输

HTTP/1.1 采用了长连接的方式，这使得**管道（pipeline）网络传输**成为了可能。

即可**在同一个 TCP 连接里面，客户端可以发起多个请求，只要第一个请求发出去了，不必等其回来，就可以发第二个请求出去**，可以**减少整体的响应时间**。

举例来说，客户端需要请求两个资源。以前的做法是，在同一个 TCP 连接里面，先发送 A 请求，然后等待服务器做出回应，收到后再发出 B 请求。那么，管道机制则是允许浏览器同时发出 A 请求和 B 请求。

但是**服务器必须按照接收请求的顺序发送对这些管道化请求的响应**。

> Q: A 请求在网络阻塞了，B 请求先于 A 请求到达服务器会怎么办？

如果服务端在处理 A 请求时耗时比较长，那么后续的请求的处理都会被阻塞住，这称为「队头堵塞」。

所以，HTTP/1.1 管道解决了请求的队头阻塞，但是没有解决响应的队头阻塞。

> TIP
>
>注意!!!
>
> 实际上 HTTP/1.1 管道化技术不是默认开启，而且**浏览器基本都没有支持**，所以后面所有文章讨论 HTTP/1.1 都是**建立在没有使用管道化的前提**。大家知道有这个功能，但是没有被使用就行了。


## 为什么我们在开发过程中从来没有关心过 HTTP 版本？
以Go语言进行网络编程举例，你可能没有直接指定使用的HTTP版本，这是因为很多现代的HTTP库和框架能够自动处理版本协商和选择。HTTP 版本的选择通常是通过**客户端和服务器之间的协商**来决定的，而**不需要开发者显式指定**。

版本协商：
+ 当客户端发起请求时，它会在请求头中包含它支持的HTTP版本信息。例如，在使用HTTP/2时，客户端可以通过TLS握手的ALPN（Application Layer Protocol Negotiation）扩展来表明它支持HTTP/2。
+ 服务器接收到请求后，会检查自己支持的版本和客户端支持的版本，选择一个共同支持的版本来响应请求。如果服务器支持HTTP/2或HTTP/3，并且客户端也支持，则会使用较新的协议版本。

在Go语言中，net/http库提供了对HTTP/1.1的支持，并且自Go 1.6起，默认支持HTTP/2，只要服务端和客户端都支持。你不需要显式地做任何设置，因为Go的HTTP客户端和服务器会自动尝试使用HTTP/2进行通信。HTTP/2的使用仅在使用HTTPS时自动启用，因为HTTP/2在大多数实现中都是通过TLS协商来启用的。

## HTTP/1.1 如何优化
我们可以从下面这三种优化思路来优化 HTTP/1.1 协议：
+ 尽量避免发送 HTTP 请求；
+ 在需要发送 HTTP 请求时，考虑如何减少请求次数；
+ 减少服务器的 HTTP 响应的数据大小；

### 如何避免发送 HTTP 请求
对于一些具有**重复性**的 HTTP 请求，比如每次请求得到的数据都一样的，我们可以把这对 **「请求-响应」的数据都缓存在本地**，那么下次就直接读取本地的数据，不必在通过网络获取服务器的响应了。

避免发送 HTTP 请求的方法就是通过**缓存技术**，HTTP 设计者早在之前就考虑到了这点，因此 HTTP 协议的头部有不少是针对缓存的字段。

客户端会把第一次请求以及响应的数据保存在本地磁盘上，其中将请求的 URL 作为 key，而响应作为 value，两者形成映射关系。

这样当后续发起相同的请求时，就可以先在本地磁盘上通过 key 查到对应的 value，也就是响应，如果找到了，就直接从本地读取该响应。毋庸置疑，读取本地磁盘的速度肯定比网络请求快得多，如下图：
{{% details title="展开图片" closed="true" %}}
![img.png](/images/cs/network/HTTP-6.png)
{{% /details %}}
万一缓存的响应不是最新的，而客户端并不知情，那么该怎么办呢？

所以，服务器在发送 HTTP 响应时，会估算一个过期的时间，并把这个信息放到响应头部中，这样客户端在查看响应头部的信息时，一旦发现缓存的响应是过期的，则就会重新发送网络请求。

如果客户端从第一次请求得到的响应头部中发现该响应过期了，客户端重新发送请求，假设服务器上的资源并没有变更，还是老样子，那么你觉得还要在服务器的响应带上这个资源吗？

很显然不带的话，可以提高 HTTP 协议的性能，那具体如何做到呢？

只需要客户端在重新发送请求时，在请求的 Etag 头部带上第一次请求的响应头部中的摘要，这个摘要是唯一标识响应的资源，当服务器收到请求后，会将本地资源的摘要与请求中的摘要做个比较。

如果不同，那么说明客户端的缓存已经没有价值，服务器在响应中带上最新的资源。

如果相同，说明客户端的缓存还是可以继续使用的，那么服务器**仅返回不含有包体的 304 Not Modified 响应**，告诉客户端仍然有效，这样就可以减少响应资源在网络中传输的延时，如下图：
{{% details title="展开图片" closed="true" %}}
![img.png](/images/cs/network/HTTP-7.png)
{{% /details %}}
### 如何减少 HTTP 请求次数
减少 HTTP 请求次数自然也就提升了 HTTP 性能，可以从这 3 个方面入手：
+ 减少重定向请求次数；
+ 合并请求；
+ 延迟发送请求；

#### 减少重定向请求次数
重定向请求：服务器上的一个资源可能由于迁移、维护等原因从 url1 移至 url2 后，而客户端不知情，它还是继续请求 url1，这时服务器不能粗暴地返回错误，而是通过 302 响应码和 Location 头部，告诉客户端该资源已经迁移至 url2 了，于是客户端需要再发送 url2 请求以获得服务器的资源。

那么，如果重定向请求越多，那么客户端就要多次发起 HTTP 请求，每一次的 HTTP 请求都得经过网络，这无疑会越降低网络性能。

另外，服务端这一方往往不只有一台服务器，比如源服务器上一级是代理服务器，然后代理服务器才与客户端通信，这时客户端重定向就会导致客户端与代理服务器之间需要 2 次消息传递，如下图：
{{% details title="展开图片" closed="true" %}}
![img.png](/images/cs/network/HTTP-8.png)
{{% /details %}}
如果**重定向的工作交由代理服务器完成，就能减少 HTTP 请求次数了**，如下图：
{{% details title="展开图片" closed="true" %}}
![img.png](/images/cs/network/HTTP-9.png)
{{% /details %}}
而且当代理服务器知晓了重定向规则后，可以进一步减少消息传递次数，如下图：
{{% details title="展开图片" closed="true" %}}
![img.png](/images/cs/network/HTTP-10.png)
{{% /details %}}
除了 302 重定向响应码，还有其他一些重定向的响应码，你可以从下图看到：
{{% details title="展开图片" closed="true" %}}
![img.png](/images/cs/network/HTTP-11.png)
{{% /details %}}
其中，301 和 308 响应码是告诉客户端可以将重定向响应缓存到本地磁盘，之后客户端就自动用 url2 替代 url1 访问服务器的资源。

#### 合并请求
如果把多个访问小文件的请求合并成一个大的请求，虽然传输的总资源还是一样，但是减少请求，也就意味着**减少了重复发送的 HTTP 头部**。

另外由于 HTTP/1.1 是请求响应模型，如果第一个发送的请求，未收到对应的响应，那么后续的请求就不会发送（PS：HTTP/1.1 管道模式是默认不使用的，所以讨论 HTTP/1.1 的队头阻塞问题，是不考虑管道模式的），于是为了防止单个请求的阻塞，所以**一般浏览器会同时发起 5-6 个请求，每一个请求都是不同的 TCP 连接**，那么如果合并了请求，也就会**减少 TCP 连接的数量，因而省去了 TCP 握手和慢启动过程耗费的时间**。

有的网页会含有很多小图片、小图标，有多少个小图片，客户端就要发起多少次请求。那么对于这些小图片，我们可以考虑使用 CSS Image Sprites 技术把它们合成一个大图片，这样浏览器就可以用一次请求获得一个大图片，然后再根据 CSS 数据把大图片切割成多张小图片。
{{% details title="展开图片" closed="true" %}}
![img.png](/images/cs/network/HTTP-12.png)
{{% /details %}}
这种方式就是**通过将多个小图片合并成一个大图片来减少 HTTP 请求的次数，以减少 HTTP 请求的次数，从而减少网络的开销**。

除了将小图片合并成大图片的方式，还有服务端使用 webpack 等打包工具将 js、css 等资源合并打包成大文件，也是能达到类似的效果。

另外，还可以将图片的二进制数据用 base64 编码后，以 URL 的形式嵌入到 HTML 文件，跟随 HTML 文件一并发送.

这样客户端收到 HTML 后，就可以直接解码出数据，然后直接显示图片，就不用再发起图片相关的请求，这样便减少了请求的次数。

**合并请求的方式就是合并资源，以一个大资源的请求替换多个小资源的请求**。

但是这样的合并请求会带来新的问题，**当大资源中的某一个小资源发生变化后，客户端必须重新下载整个完整的大资源文件**，这显然带来了额外的网络消耗。

#### 延迟发送请求
一般 HTML 里会含有很多 HTTP 的 URL，当前不需要的资源，我们没必要也获取过来，于是可以通过「**按需获取**」的方式，来减少第一时间的 HTTP 请求次数。

请求网页的时候，没必要把全部资源都获取到，而是只获取当前用户所看到的页面资源，当用户向下滑动页面的时候，再向服务器获取接下来的资源，这样就达到了延迟发送请求的效果。

### 如何减少 HTTP 响应的数据大小
对于 HTTP 的请求和响应，通常 HTTP 的响应的数据大小会比较大，也就是服务器返回的资源会比较大。

于是，我们可以考虑对响应的资源进行**压缩**，这样就可以减少响应的数据大小，从而提高网络传输的效率。

#### 无损压缩
无损压缩是指资源经过压缩后，信息不被破坏，还能完全恢复到压缩前的原样，适合用在**文本文件、程序可执行文件、程序源代码**。

gzip 就是比较常见的无损压缩。客户端支持的压缩算法，会在 HTTP 请求中通过头部中的 Accept-Encoding 字段告诉服务器：
```text
Accept-Encoding: gzip, deflate, br
```
服务器收到后，会从中选择一个服务器支持的或者合适的压缩算法，然后使用此压缩算法对响应资源进行压缩，最后通过响应头部中的 Content-Encoding 字段告诉客户端该资源使用的压缩算法。
```text
Content-Encoding: gzip
```
gzip 的压缩效率相比 Google 推出的 Brotli 算法还是差点意思，也就是上文中的 br，所以如果可以，服务器应该选择压缩效率更高的 br 压缩算法。

> 对于HTTP响应的压缩处理，通常情况下，开发者不需要手动压缩响应内容和设置响应字段。大多数现代的Web服务器和应用框架提供了自动的响应压缩功能，能够根据客户端的Accept-Encoding请求头自动选择合适的压缩算法来压缩响应数据，并自动设置Content-Encoding响应头以通知客户端使用的压缩算法。

#### 有损压缩
与无损压缩相对的就是有损压缩，经过此方法压缩，解压的数据会与原始数据不同但是非常接近

有损压缩主要将次要的数据舍弃，牺牲一些质量来减少数据量、提高压缩比，这种方法经常用于压缩多媒体数据，比如音频、视频、图片。

可以通过 HTTP 请求头部中的 Accept 字段里的「 q 质量因子」，告诉服务器期望的资源质量。
```text
Accept: audio/*; q=0.2, audio/basic
```
关于图片的压缩，目前压缩比较高的是 Google 推出的 WebP 格式，它与常见的 Png 格式图片的压缩比例对比如下图：

关于音视频的压缩，音视频主要是动态的，每个帧都有时序的关系，通常时间连续的帧之间的变化是很小的。

比如，一个在看书的视频，画面通常只有人物的手和书桌上的书是会有变化的，而其他地方通常都是静态的，于是只需要在一个静态的关键帧，使用**增量数据**来表达后续的帧，这样便减少了很多数据，提高了网络传输的性能。对于视频常见的编码格式有 H264、H265 等，音频常见的编码格式有 AAC、AC3。
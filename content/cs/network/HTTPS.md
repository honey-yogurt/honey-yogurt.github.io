+++
title = 'HTTPS'
date = 2024-04-03T09:09:39+08:00
+++

## HTTP 与 HTTPS 有哪些区别
HTTP 是超文本传输协议，信息是明文传输，存在安全风险的问题。HTTPS 则解决 HTTP 不安全的缺陷，**在 TCP 和 HTTP 网络层之间加入了 SSL/TLS 安全协议**，使得报文能够**加密传输**。

HTTP 连接建立相对简单， TCP 三次握手之后便可进行 HTTP 的报文传输。而 HTTPS 在 TCP 三次握手之后，还需进行 **SSL/TLS 的握手过程**，才可进入加密报文传输。

两者的默认端口不一样，HTTP 默认端口号是 80，HTTPS 默认端口号是 443。

HTTPS 协议需要向 CA（证书权威机构）申请数字证书，来保证服务器的身份是可信的。

## HTTPS 解决了 HTTP 的哪些问题
HTTP 由于是明文传输，所以安全上存在以下三个风险：
+ 窃听风险，比如通信链路上可以获取通信内容。
+ 篡改风险，比如强制植入垃圾广告。
+ 冒充风险，比如冒充淘宝网站。

HTTPS 在 HTTP 与 TCP 层之间加入了 SSL/TLS 协议，可以很好的解决了上述的风险：
+ 信息加密：交互信息无法被窃取。
+ 校验机制：无法篡改通信内容，篡改了就不能正常显示。
+ 身份证书：证明淘宝是真的淘宝网。

HTTPS 是如何解决上面的三个风险的？
+ 混合加密的方式实现信息的机密性，解决了窃听的风险。
+ 摘要算法的方式来实现完整性，它能够为数据生成独一无二的「指纹」，指纹用于校验数据的完整性，解决了篡改的风险。
+ 将服务器公钥放入到数字证书中，解决了冒充的风险

### 混合加密
通过混合加密的方式可以保证信息的机密性，解决了窃听的风险。
{{% details title="展开图片" closed="true" %}}
![img.png](/images/cs/network/HTTPS-1.png)
{{% /details %}}
HTTPS 采用的是对称加密和非对称加密结合的「混合加密」方式：
+ 在通信建立前采用**非对称加密的方式交换「会话秘钥」**，后续就不再使用非对称加密。
+ 在通信过程中全部使用**对称加密的「会话秘钥」的方式加密**明文数据。

采用「混合加密」的方式的原因：
+ 对称加密只使用一个密钥，**运算速度快**，密钥必须保密，无法做到安全的密钥交换。
+ 非对称加密使用两个密钥：公钥和私钥，公钥可以任意分发而私钥保密，解决了密钥交换问题但**速度慢**。

### 摘要算法 和 数字签名

**为了保证传输的内容不被篡改**，我们需要对内容计算出一个「指纹」，然后同内容一起传输给对方。

对方收到后，先是对内容也计算出一个「指纹」，然后跟发送方发送的「指纹」做一个比较，如果「指纹」相同，说明内容没有被篡改，否则就可以判断出内容被篡改了。

那么，在计算机里会用摘要算法（哈希函数）来计算出内容的哈希值，也就是内容的「指纹」，这个哈希值是唯一的，且无法通过哈希值推导出内容。

通过哈希算法可以确保内容不会被篡改，但是**并不能保证「内容 + 哈希值」不会被中间人替换，因为这里缺少对客户端收到的消息是否来源于服务端的证明**。

那为了避免这种情况，计算机里会用非对称加密算法来解决，共有两个密钥：
+ 一个是公钥，这个是可以公开给所有人的；
+ 一个是私钥，这个必须由本人管理，不可泄露。

通过私钥签名，公钥验签的方式来确认消息的身份。我们常说的**数字签名算法**，就是用的是这种方式，不过私钥签名内容不是内容本身，而是**对内容的哈希值签名**。

### 数字证书
前面我们知道：
+ 可以通过哈希算法来保证消息的完整性；
+ 可以通过数字签名来保证消息的来源可靠性（能确认消息是由持有私钥的一方发送的）；

但是这还远远不够，还缺少身份验证的环节，万一公钥是被伪造的呢？

数字证书属于PKI体系核心部分，只需要知道数字证书是一个权威机构对某一个身份的公钥的证明就行了，证明这个公钥属于某个身份。

### HTTPS 是如何建立连接的？其间交互了什么？
SSL/TLS 协议基本流程：
+ 客户端向服务器索要并验证服务器的公钥。
+ 双方协商生产「会话秘钥」。
+ 双方采用「会话秘钥」进行加密通信。

前两步也就是 SSL/TLS 的建立过程，也就是 **TLS 握手阶段**。

TLS 的「握手阶段」涉及四次通信，使用不同的密钥交换算法，TLS 握手流程也会不一样的，现在常用的密钥交换算法有两种：[RSA算法](/cs/network/https-rsa)和 [ECDHE算法](/cs/network/https-ecdhe)。

## HTTPS 的应用数据是如何保证完整性的
TLS 在实现上分为**握手协议**和**记录协议**两层：
+ TLS 握手协议就是我们前面说的 TLS 四次握手的过程，负责协商加密算法和生成对称密钥，后续用此密钥来保护应用程序数据（即 HTTP 数据）；
+ TLS 记录协议负责**保护应用程序数据并验证其完整性和来源**，所以对 HTTP 数据加密是使用记录协议；

TLS 记录协议主要负责消息（HTTP 数据）的**压缩，加密及数据的认证**，过程如下图：
{{% details title="展开图片" closed="true" %}}
![img.png](/images/cs/network/HTTPS-2.png)
{{% /details %}}

具体过程如下：
+ 首先，消息被分割成多个较短的片段,然后分别对每个片段进行压缩。
+ 接下来，经过压缩的片段会被加上**消息认证码**（MAC 值，这个是通过哈希算法生成的），这是为了**保证完整性**，**并进行数据的认证**。通过附加消息认证码的 MAC 值，可以识别出篡改。与此同时，为了**防止重放攻击**，在计算消息认证码时，还加上了**片段的编码**。
+ 再接下来，经过**压缩的片段再加上消息认证码会一起通过对称密码进行加密**。
+ 最后，上述经过加密的数据再**加上由数据类型、版本号、压缩后的长度组成的报头**就是最终的报文数据。

记录协议完成后，最终的报文数据将传递到传输控制协议 (TCP) 层进行传输。
如果你想详细了解记录协议是如何分片、压缩、计算 MAC 值、分组加密，可以看这篇：[理解SSL/TLS系列 (四) 记录协议](https://blog.csdn.net/zhanyiwp/article/details/105627799)

## HTTPS 一定安全可靠吗？
客户端通过浏览器向服务端发起 HTTPS 请求时，被「假基站」转发到了一个「中间人服务器」，于是客户端是和「中间人服务器」完成了 TLS 握手，然后这个「中间人服务器」再与真正的服务端完成 TLS 握手。
{{% details title="展开图片" closed="true" %}}
![img.png](/images/cs/network/HTTPS-3.png)
{{% /details %}}
具体过程如下：
+ 客户端向服务端发起 HTTPS 建立连接请求时，然后被「假基站」转发到了一个「中间人服务器」，接着中间人向服务端发起 HTTPS 建立连接请求，此时客户端与中间人进行 TLS 握手，中间人与服务端进行 TLS 握手；
+ 在客户端与中间人进行 TLS 握手过程中，中间人会发送自己的公钥证书给客户端，客户端验证证书的真伪，然后从证书拿到公钥，并生成一个随机数，用公钥加密随机数发送给中间人，中间人使用私钥解密，得到随机数，此时双方都有随机数，然后通过算法生成对称加密密钥（A），后续客户端与中间人通信就用这个对称加密密钥来加密数据了。
+ 在中间人与服务端进行 TLS 握手过程中，服务端会发送从 CA 机构签发的公钥证书给中间人，从证书拿到公钥，并生成一个随机数，用公钥加密随机数发送给服务端，服务端使用私钥解密，得到随机数，此时双方都有随机数，然后通过算法生成对称加密密钥（B），后续中间人与服务端通信就用这个对称加密密钥来加密数据了。
+ 后续的通信过程中，中间人用对称加密密钥（A）解密客户端的 HTTPS 请求的数据，然后用对称加密密钥（B）加密 HTTPS 请求后，转发给服务端，接着服务端发送 HTTPS 响应数据给中间人，中间人用对称加密密钥（B）解密 HTTPS 响应数据，然后再用对称加密密钥（A）加密后，转发给客户端。

从客户端的角度看，其实并不知道网络中存在中间人服务器这个角色。那么中间人就可以解开浏览器发起的 HTTPS 请求里的数据，也可以解开服务端响应给浏览器的 HTTPS 响应数据。相当于，中间人能够 “偷看” 浏览器与服务端之间的 HTTPS 请求和响应的数据。

但是要发生这种场景是有前提的，前提是用户点击接受了中间人服务器的证书。

中间人服务器与客户端在 TLS 握手过程中，**实际上发送了自己伪造的证书给浏览器，而这个伪造的证书是能被浏览器（客户端）识别出是非法的，于是就会提醒用户该证书存在问题**。

如果用户执意点击「继续浏览此网站」，相当于用户接受了中间人伪造的证书，那么后续整个 HTTPS 通信都能被中间人监听了。

所以，**HTTPS 协议本身到目前为止还是没有任何漏洞的，即使你成功进行中间人攻击，本质上是利用了客户端的漏洞（用户点击继续访问或者被恶意导入伪造的根证书），并不是 HTTPS 不够安全**。

## 为什么抓包工具能截取 HTTPS 数据？
对于 HTTPS 连接来说，中间人要满足以下两点，才能实现真正的明文代理:
+ 中间人，作为客户端与真实服务端建立连接这一步不会有问题，因为服务端不会校验客户端的身份；
+ 中间人，作为服务端与真实客户端建立连接，这里会有客户端信任服务端的问题，也就是服务端必须有对应域名的私钥；

中间人要拿到私钥只能通过如下方式：
+ 去网站服务端拿到私钥；
+ 去CA处拿域名签发私钥；
+ 自己签发证书，且要被浏览器信任；

显然，抓包工具只能使用第三种方式取得中间人的身份。

使用抓包工具进行 HTTPS 抓包的时候，需要在客户端安装 **Fiddler 的根证书**，这里实际上起认证中心（CA）的作用。

抓包工具能够抓包的关键是客户端会往系统受信任的根证书列表中导入抓包工具生成的证书，而这个证书会被浏览器信任，也就是抓包工具给自己创建了一个认证中心 CA，客户端拿着中间人签发的证书去中间人自己的 CA 去认证，当然认为这个证书是有效的。

如何避免被中间人抓取数据？

我们要保证自己电脑的安全，不要被病毒乘虚而入，而且也不要点击任何证书非法的网站，这样 HTTPS 数据就不会被中间人截取到了。

当然，我们还可以通过 **HTTPS 双向认证**来避免这种问题。

一般我们的 HTTPS 是单向认证，客户端只会验证了服务端的身份，但是服务端并不会验证客户端的身份。
{{% details title="展开图片" closed="true" %}}
![img.png](/images/cs/network/HTTPS-4.png)
{{% /details %}}

如果用了双向认证方式，不仅客户端会验证服务端的身份，而且服务端也会验证客户端的身份。服务端一旦验证到请求自己的客户端为不可信任的，服务端就拒绝继续通信，客户端如果发现服务端为不可信任的，那么也中止通信。













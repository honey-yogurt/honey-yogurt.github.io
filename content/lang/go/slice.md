+++
title = '切片'
date = 2024-04-11T10:51:31+08:00
+++

Slice依托数组实现，底层数组对用户屏蔽，在底层数组容量不足时可以实现自动重分配并生成新的Slice。

## 数据结构
```go
// src/runtime/slice.go
type slice struct {
    array unsafe.Pointer    // 引用着底层存储在间接部分上的元素（指向底层的数组的指针）
	len      int            // 长度
	cap      int            // 容量
}
```
下面这张图描绘了一个切片值的内存布局。
{{% details title="展开图片" closed="true" %}}
![img.png](/images/lang/go/slice-4.png)
{{% /details %}}

尽管一个切片值的底层元素部分可能位于一个比较大的内存片段上，但是此切片值只能感知到此**内存片段上的一个子片段**。 比如，上图中的切片值只能感知到灰色的子片段。

在上图中，从下标`len`（包含）到下标`cap`（不包含）对应的元素并不属于图中所示的切片值。 它们只是此切片之中的一些冗余元素槽位，但是**它们可能是其它切片（或者数组）值中的有效元素**。

## 声明以及初始化
```go
var s []int
```
### 使用字面量初始化新的切片
```go
s = []int{1,2,3}
```
当我们使用字面量 []int{1, 2, 3} 创建新的切片时，编译器会在编译期间将它展开如下所示的代码片段：
```go
var vstat [3]int
vstat[0] = 1
vstat[1] = 2
vstat[2] = 3
var vauto *[3]int = new([3]int)
*vauto = vstat
slice := vauto[:]
```
+ 根据切片中的元素数量对底层数组的大小进行推断并**创建一个数组**
+ 将这些字面量元素存储到初始化的数组中
+ 创建一个同样指向 [3]int 类型的数组指针
+ 将静态存储区的数组 vstat 赋值给 vauto 指针所在的地址；
+ 通过 [:] 操作获取一个底层使用 vauto 的切片

最后一步的 [:] 就是使用下标创建切片的方法，从这一点我们也能看出 [:] 操作是创建切片最底层的一种方法。
### 使用数组或者切片（下标）创建切片
```go
a := [5]int{1,2,3,4,5}
s1 := a[0:3]
s2 := s1[0:2]
```
{{% details title="展开图片" closed="true" %}}
![img.png](/images/lang/go/slice-2.png)
{{% /details %}}
使用下标初始化切片**不会拷贝**原数组或者原切片中的数据，它只会创建一个指向原数组（切片）的切片结构体，所以修改新切片的数据也会修改原数组（切片）。
即**新切片和原数组共享一部分内存**。

> Q: 为什么不说新切片和原切片共享一部分内存呢？
> 
> A: 因为原切片也是和底层数组共享内存。

切片从数组array[5]开始，到数组array[7]结束（不含array[7]），即切片长度为2，**数组后面的内容都作为切片的预留内存**，即capacity为5。

实际上，Go中有两种取子切片的语法形式（假设`baseContainer`是一个切片或者数组）：
```go
baseContainer[low : high]       // 双下标形式
baseContainer[low : high : max] // 三下标形式
```
上面所示的双下标形式等价于下面的三下标形式：
```go
baseContainer[low : high : cap(baseContainer)]
```
上面所示的取子切片表达式的语法形式中的下标必须满足下列关系，否则代码要么编译不通过，要么在运行时刻将造成panic。
```go
// 双下标形式
0 <= low <= high <= cap(baseContainer)

// 三下标形式
0 <= low <= high <= max <= cap(baseContainer)
```
如果`baseContainer`是一个零值nil切片，只要上面所示的子切片表达式中**下标的值均为`0`**，则这两个子切片表达式**不会造成panic**。 在这种情况下，结果**切片也是一个nil切片**。

**子切片表达式的结果切片的长度为`high - low`、容量为`max - low`。 派生出来的结果切片的长度可能大于基础切片的长度，但结果切片的容量绝不可能大于基础切片的容量**。

在实践中，我们常常在子切片表达式中省略若干下标，以使代码看上去更加简洁。省略规则如下：
- 如果下标`low`为零，则它可被省略。此条规则同时适用于双下标形式和三下标形式。
- 如果下标`high`等于`len(baseContainer)`，则它可被省略。此条规则只适用于双下标形式。
- 三下标形式中的下标`max`在任何情况下都不可被省略。
```go
package main

import "fmt"

func main() {
	a := [...]int{0, 1, 2, 3, 4, 5, 6}
	s0 := a[:]     // <=> s0 := a[0:7:7]
	s1 := s0[:]    // <=> s1 := s0
	s2 := s1[1:3]  // <=> s2 := a[1:3]
	s3 := s1[3:]   // <=> s3 := s1[3:7]
	s4 := s0[3:5]  // <=> s4 := s0[3:5:7]
	s5 := s4[:2:2] // <=> s5 := s0[3:5:5]
	s6 := append(s4, 77)
	s7 := append(s5, 88)
	s8 := append(s7, 66)
	s3[1] = 99
	fmt.Println(len(s2), cap(s2), s2) // 2 6 [1 2]
	fmt.Println(len(s3), cap(s3), s3) // 4 4 [3 99 77 6]
	fmt.Println(len(s4), cap(s4), s4) // 2 4 [3 99]
	fmt.Println(len(s5), cap(s5), s5) // 2 2 [3 99]
	fmt.Println(len(s6), cap(s6), s6) // 3 4 [3 99 77]
	fmt.Println(len(s7), cap(s7), s7) // 3 4 [3 4 88]
	fmt.Println(len(s8), cap(s8), s8) // 4 4 [3 4 88 66]
}
```
下面这张图描绘了上面的程序在退出之前各个数组和切片的状态。
{{% details title="展开图片" closed="true" %}}
![img.png](/images/lang/go/slice-3.png)
{{% /details %}}
从这张图片可以看出，切片`s7`和`s8`共享存储它们的元素的底层内存片段，其它切片和数组`a`共享同一个存储元素的内存片段。

请注意，子切片操作有可能会造成**暂时性的内存泄露**。 比如，下面在这个函数中开辟的内存块中的前50个元素槽位在它的调用返回之后将不再可见。 这50个元素槽位所占内存浪费了，这属于暂时性的内存泄露。 当这个函数中开辟的内存块今后不再被任何切片所引用，此内存块将被回收，这时内存才不再继续泄漏。
```go
func f() []int {
	s := make([]int, 10, 100)
	return s[50:60]
}
```
请注意，在上面这个函数中，子切片表达式中的起始下标（`50`）比`s`的长度（`10`）要大，这是允许的。


### 使用 make创建切片
使用make来创建Slice时，可以同时指定长度和容量，创建时底层会分配一个数组，数组的长度即容量。
```go
make(S, length, capacity)
make(S, length) // <=> make(S, length, length)
```
具体如下：
```go
s := make([]int,5,10)
```
{{% details title="展开图片" closed="true" %}}
![img.png](/images/lang/go/slice-1.png)
{{% /details %}}
该Slice长度为5，即可以使用下标slice[0] ~ slice[4]来操作里面的元素，capacity为10，表示后续向slice添加新的元素时可以不必重新分配内存，直接使用预留内存即可。

使用`make`函数创建的切片中的所有元素值均被初始化为（结果切片的元素类型的）零值。

### 使用 new 创建切片
内置`new`函数可以用来为**一个任何类型的值开辟内存**并返回一个存储有此值的地址的指针。 用`new`函数开辟出来的值均为**零值**。因为这个原因，`new`函数**对于创建映射和切片值来说没有任何价值**。

使用`new`函数来用来创建数组值并非是完全没有意义的，但是在实践中很少这么做，因为使用组合字面量来创建数组值更为方便。


## 切片的地址
同数组不同的是，一个切片的变量名取地址和这个切片下标为0的元素不是同一个地址，这也可以由切片的底层数据结构得出这个结论。即切片本身是持有一个数组指针的结构体。
```go
s := []int{1, 2}
	fmt.Printf("s: %p\n", &s)   // s: 0xc0000084e0
	fmt.Printf("s[0]: %p\n", &s[0]) // s[0]: 0xc00000a660
```
## 赋值
在 Go 语言中所有的赋值操作均是源值被复制给了目标值。精确地说，**源值的直接部分**被**复制**给了目标值。

注意：函数传参和结果返回其实都是赋值

所以切片的赋值操作，等于把源值切片结构体中三个字段挨个复制给目标切片中的三个字段，也就是 **底层数组的指针(地址)** 被复制过去了，从而赋值就是共享了底层的数组。
## 内置函数 copy
我们可以使用内置`copy`函数来将**一个切片中的元素复制到另一个切片**。`copy`函数的第一个参数为目标切片，第二个参数为源切片。 传递给一个`copy`函数调用的两个实参可以共享一些底层元素。 `copy`函数返回复制了多少个元素，拷贝数量取两个切片长度的最小值，即**copy过程中不会发生扩容**。

这两个切片的类型可以不同，但是**两个切片的类型的底层类型必须相同**

我们可以使用`copy`函数来在两个数组之间或者一个数组与一个切片之间复制元素。
```go
package main

import "fmt"

func main() {
	type Ta []int
	type Tb []int
	dest := Ta{1, 2, 3}
	src := Tb{5, 6, 7, 8, 9}
	n := copy(dest, src)
	fmt.Println(n, dest) // 3 [5 6 7]
	n = copy(dest[1:], dest) // copy 目标切片是子切片，共享底层切片
	fmt.Println(n, dest) // 2 [5 5 6]

	a := [4]int{} // 一个数组
	n = copy(a[:], src)
	fmt.Println(n, a) // 4 [5 6 7 8]
	n = copy(a[:], a[2:])
	fmt.Println(n, a) // 2 [7 8 7 8]
}
```

注意，做为一个特例，`copy`函数可以用来将一个字符串中的字节复制到一个字节切片。
> 语法糖：将**字符串当作字节切片使用**
> 
> 内置函数`copy`和`append`可以用来复制和添加切片元素。 事实上，做为一个特例，如果这两个函数的调用中的第一个实参为一个字节切片的话，那么**第二个实参可以是一个字符串**。（对于`append`函数调用，字符串实参后必须跟随三个点`...`。） 换句话说，在此特例中，字符串可以当作字节切片来使用。
> ```go
>package main
>
>import "fmt"
>
>func main() {
>hello := []byte("Hello ")
>world := "world!"
>
>	// helloWorld := append(hello, []byte(world)...) // 正常的语法
>	helloWorld := append(hello, world...)            // 语法糖
>	fmt.Println(string(helloWorld))
>
>	helloWorld2 := make([]byte, len(hello) + len(world))
>	copy(helloWorld2, hello)
>	// copy(helloWorld2[len(hello):], []byte(world)) // 正常的语法
>	copy(helloWorld2[len(hello):], world)            // 语法糖
>	fmt.Println(string(helloWorld2))
>}
>```

截至目前（Go 1.21），`copy`函数调用的两个实参均不能为类型不确定的`nil`。

## 内置函数 append
我们可以通过调用内置`append`函数，以一个切片为基础，来添加不定数量的元素并**返回一个新的切片**。 此新的结果切片包含着基础切片中所有的元素和所有被添加的元素。 注意，**基础切片并未被此`append`函数调用所修改**。 当然，如果我们愿意（事实上在实践中常常如此），我们可以将结果切片赋值给基础切片以修改基础切片。

注意，内置`append`函数是一个变长参数函数（后续介绍）。 它有两个参数，其中第二个参数（形参）为一个变长参数。

```go
s0 := []int{2, 3, 5}
	fmt.Println(s0, cap(s0)) // [2 3 5] 3
	s1 := append(s0, 7)      // 添加一个元素
	fmt.Println(s1, cap(s1)) // [2 3 5 7] 6
	s2 := append(s1, 11, 13) // 添加两个元素
	fmt.Println(s2, cap(s2)) // [2 3 5 7 11 13] 6
	s3 := append(s0)         // <=> s3 := s0
	fmt.Println(s3, cap(s3)) // [2 3 5] 3
	s4 := append(s0, s0...)  // 以s0为基础添加s0中所有的元素
	fmt.Println(s4, cap(s4)) // [2 3 5 2 3 5] 6

	s0[0], s1[0] = 99, 789
	fmt.Println(s2[0], s3[0], s4[0]) // 789 99 2
```
对于**三个点**方式，`append`函数并不要求**第二个实参的类型和第一个实参一致**，但是它们的**元素类型必须一致**。 换句话说，它们的**底层类型必须一致**。

在上面的程序中，

- 第*8*行的`append`函数调用将为结果切片`s1`开辟一段新的内存。 原因是切片`s0`中没有足够的冗余元素槽位来容纳新添加的元素。 第*14*行的`append`函数调用也是同样的情况。
- 第*10*行的`append`函数调用不会为结果切片`s2`开辟新的内存片段。 原因是切片`s1`中的冗余元素槽位足够容纳新添加的元素。

所以，上面的程序中在退出之前，切片`s1`和`s2`共享一些元素，切片`s0`和`s3`共享所有的元素。 下面这张图描绘了在上面的程序结束之前各个切片的状态。
{{% details title="展开图片" closed="true" %}}
![img.png](/images/lang/go/slice-5.png)
{{% /details %}}
使用append向Slice追加元素时，如果Slice空间不足，将会触发Slice扩容，扩容实际上**重新分配一块更大的内存**，将原Slice **数据拷贝** 进新Slice，然后返回新Slice，**扩容后再将数据追加**进去。

例如，当向一个capacity为5，且length也为5的Slice再次追加1个元素时，就会发生扩容，如下图所示：
{{% details title="展开图片" closed="true" %}}
![img.png](/images/lang/go/slice-6.png)
{{% /details %}}
**扩容操作只关心容量**，会把原Slice数据拷贝到新Slice，**追加数据由append在扩容结束后完成**。上图可见，扩容后新的Slice长度仍然是5，但容量由5提升到了10，原Slice的数据也都拷贝到了新Slice指向的数组中。

扩容容量的选择遵循以下规则：
+ 如果原Slice容量小于1024，则新Slice容量将扩大为原来的2倍；
+ 如果原Slice容量大于等于1024，则新Slice容量将扩大为原来的1.25倍；

使用append()向Slice添加一个元素的实现步骤如下：
+ 假如Slice容量够用，则将新元素追加进去，Slice.len++，返回原Slice
+ 原Slice容量不够，则将Slice先扩容，扩容后得到新Slice
+ 将新元素追加进新Slice，Slice.len++，返回新的Slice。

创建切片时可跟据实际需要**预分配容量**，尽量避免追加过程中扩容操作，有利于提升性能；因为扩容产生的拷贝是一个成本比较大的操作。

截至目前（Go 1.21），`append`函数调用的第一个实参不能为类型不确定的`nil`。
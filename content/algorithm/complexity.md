---
title: '代码复杂度'
date: 2024-06-24T22:33:50+08:00
params:
    math: true
---
## 时间复杂度

```c
int cal(int n) {
	int sum = 0;
 	int i = 1;
 	int j = 1;
 	for (; i <= n; ++i) {
 		j = 1;
 		for (; j <= n; ++j) {
 			sum = sum + i * j;
 		}
 	}
 }
```

从CPU的角度来看，这段代码的每一行都执行着类似的操作：读数据-运算-写数据。尽管每行代码对应的CPU执行的个数、执行的时间都不一样，但是，我们这里只是粗略估计，所以可以**假设每行代码执行的时间都一样**，为uint_time。

第2、3、4行代码，每行都需要1个unit_time的执行时间，第5、6行代码循环执行了 n 遍，需要 2n * unit_time  的执行时间，第7、8行代码循环执行了$n^2$遍，所以需要$2n^2$ * unit_time的执行时间。所以，整段代码总的执行时间T(n) = $(2n^2+2n+3)$*unit_time。

**所有代码的执行时间T(n)与每行代码 的执行次数n成正比**。 

$$T(n) = O(f(n))$$

**T(n)表示代码执行的时间；n表示数据规模的大小；f(n)表示每行代码执行的次数总和；O表示代码的执行时间T(n)与f(n)表达式成正比。**

大O时间复杂度实际上并不具体表示代码真正的执行时间，而是表示**代码执行时间随数据规模增长的变化趋势**，所以，也叫作**渐进时间复杂度**，简称时间复杂度。

当n很大时，我们只需要记录一个**最大量级**就可以 了，所以上面代码的时间复杂度是 $T(n)=O(n^2)$。

在计算时间复杂度时候，有几个使用的方法：

+ 总复杂度等于量级最大的那段代码的复杂度，只关注循环执行次数最多的一段代码。
+ 嵌套代码的复杂度等于嵌套内外代码复杂度的乘积。

![复杂度量级](/images/algorithm/algo-fuzadu-1.png)

当然代码不一定只有一个规模复杂度 n 来决定的，还有可能由多个规模复杂度决定的。比如 $O(m+n)$，$O(m*n)$，如下：

```c
int cal(int m, int n) {
 	int sum_1 = 0;
	int i = 1;
 	for (; i < m; ++i) {
 		sum_1 = sum_1 + i;
 	}
 	int sum_2 = 0;
 	int j = 1;
 	for (; j < n; ++j) {
 		sum_2 = sum_2 + j;
 	}
 	return sum_1 + sum_2;
}
```

m和n是表示两个数据规模。**我们无法事先评估m和n谁的量级大**，所以我们在表示复杂度的时候，就不能简单地利用加法法则，省略掉其中一 个。所以，上面代码的时间复杂度就是$O(m+n)$。

## 空间复杂度

空间复杂度全称就是渐进空间复杂度，表示**算法的存储空间与数据规模之间的增长关系**。

```c
void print(int n) {
 	int i = 0;
 	int[] a = new int[n];
 	for (i; i <n; ++i) {
 		a[i] = i * i;
 	}
 	for (i = n-1; i >= 0; --i) {
 		print out a[i]
 	}
}
```

我们可以看到，第2行代码中，我们申请了一个空间存储变量i，但是它是常量阶的，跟数据规模n没有关系，所以我们可以忽略。第3行申请了一个大小为n的int类型数组，除此之外，剩下的代码都没有占用更多的空间，所以整段代码的空间复杂度就是O(n)。

## 浅析最好、最坏、平均、均摊时间复杂度

### 最好、最坏情况时间复杂度

```c
// n表示数组array的长度
int find(int[] array, int n, int x) {
 	int i = 0;
 	int pos = -1;
 	for (; i < n; ++i) {
 		if (array[i] == x) {
 			pos = i;
 			break;
 		}
 	}
 	return pos;
}
```

要查找的变量x可能出现在数组的任意位置。如果数组中第一个元素正好是要查找的变量x，那就不需要继续遍历剩下的n-1个数据了，那时间复杂度就是O(1)。但如果数组中不存在变量x，那我们就需要把整个数组都遍历一遍，时间复杂度就成了O(n)。所以，不同的情况下，这段代码的时间复杂度是不一样的。

为了表示代码在不同情况下的不同时间复杂度，我们需要引入三个概念：最好情况时间复杂度、最坏情况时间复杂度和平均情况时间复杂度。

显然这个例子中，最好情况时间复杂度是 $O(1)$，最坏时间复杂度是$O(n)$。

### 平均情况时间复杂度

最好情况时间复杂度和最坏情况时间复杂度对应的都是极端情况下的代码复杂度，发生的概率其实并不大。为了更好地表示平均情况下的复杂度， 我们需要引入另一个概念：平均情况时间复杂度，后面我简称为平均时间复杂度。

要查找的变量x在数组中的位置，有n+1种情况：在数组的0～n-1位置中和不在数组中。我们把每种情况下，查找需要遍历的元素个数累加起来，然后再除以n+1， 就可以得到需要遍历的元素个数的平均值，即：

![平均时间复杂度](/images/algorithm/algo-fuzadu-2.png)

我们知道，时间复杂度的大O标记法中，可以省略掉系数、低阶、常量，所以，咱们把刚刚这个公式简化之后，得到的平均时间复杂度就是O(n)。

这个结论虽然是正确的，但是计算过程稍微有点儿问题。究竟是什么问题呢？我们刚讲的这n+1种情况，出现的概率并不是一样的。

我们知道，要查找的变量x，要么在数组里，要么就不在数组里。这两种情况对应的概率统计起来很麻烦，为了方便你理解，我们假设在数组中与不在数组中的概率都为$\frac{1}{2}$。另外，要查找的数据出现在0～n-1这n个位置的概率也是一样的，为$\frac{1}{n}$。所以，根据概率乘法法则，要查找的数据出现在0～n-1中任意位置的概率就 是$\frac{1}{2n}$。

![概率时间复杂度](/images/algorithm/algo-fuzadu-3.png)

这个值就是概率论中的加权平均值，也叫作期望值，所以**平均时间复杂度的全称应该叫加权平均时间复杂度或者期望时间复杂度**。

实际上，在大多数情况下，我们并不需要区分最好、最坏、平均情况时间复杂度三种情况。**只有同一块代码在不同的情况下，时间复杂度有量级的差距**，我们才会使用这三种复杂度表示法来区分。

### 均摊时间复杂度

平均复杂度只在某些特殊情况下才会用到，而均摊时间复杂度应用的场景比它更加特殊、更加有限。

```c
 // array表示一个长度为n的数组
 // 代码中的array.length就等于n
 int[] array = new int[n];
 int count = 0;

 void insert(int val) {
 	if (count == array.length) {
 		int sum = 0;
 		for (int i = 0; i < array.length; ++i) {
 			sum = sum + array[i];
 		}
 		array[0] = sum;
 		count = 1;
 	}
 	array[count] = val;
 	++count;
 }
```

这段代码实现了一个往数组中插入数据的功能。当数组满了之后，也就是代码中的count == array.length时，我们用for循环遍历数组求和，并清空数组，将求和之后的sum值放到数组的第一个位置，然后再将新的数据插入。但如果数组一开始就有空闲空间，则直接将数据插入数组。

最理想的情况下，数组中有空闲空间，我们只需要将数据插入到数组下标为count的位置就可以了，所以最好情况时间复杂度为O(1)。最坏的情况下，数组中没有空闲空间了，我们需要先做一次数组的遍历求和，然后再将数据插入，所以最坏情况时间复杂度为O(n)。

那平均时间复杂度是多少呢？答案是O(1)。我们还是可以通过前面讲的概率论的方法来分析。

假设数组的长度是n，根据数据插入的位置的不同，我们可以分为n种情况，每种情况的时间复杂度是O(1)。除此之外，还有一种“额外”的情况，就是在数组没有空闲空间时插入一个数据，这个时候的时间复杂度是O(n)。而且，这n+1种情况发生的概率一样，都是$\frac{1}{n+1}$。所以，根据加权平均的计算方法，我们求得的平均时间复杂度就是：

![平均复杂度](/images/algorithm/algo-fuzadu-4.png)

我们先来对比一下这个insert()的例子和前面那个find()的例子，你就会发现这两者有很大差别。

首先，find()函数在**极端情况**下，复杂度才为O(1)。但insert()在**大部分情况**下，时间复杂度都为O(1)。只有个别情况下，复杂度才比较高，为O(n)。这是insert()第一 个区别于find()的地方。

第二个不同的地方：对于insert()函数来说，O(1)时间复杂度的插入和O(n)时间复杂度的插入，出现的频率是非常**有规律的**，而且**有一定的前后时序关 系**，一般都是一个O(n)插入之后，紧跟着n-1个O(1)的插入操作，循环往复。

针对这种特殊的场景，我们引入了一种更加简单的分析方法：**摊还分析法**，通过摊还分析得到的时间复杂度我们起了一个名字，叫均摊时间复杂度。

每一次O(n)的插入操作，都会跟着n-1次O(1)的插入操作，所以把耗时多的那次操作均摊到接下来的n-1次耗时少的操作上，均摊下来，这一组连续的操作的均摊时间复杂度就是O(1)。这就是均摊分析的大致思路。

对一个数据结构进行**一组连续操作**中，**大部分情况下时间复杂度都很低，只有个别情况下时间复杂度比较高**，而且这些**操作之间存在前后连贯的时序关系**，这个时候，我们就可以将这**一组操作放在一块儿分析**，看是否能将较高时间复杂度那次操作的耗时，**平摊**到其他那些时间复杂度比较低的操作上。而且，在能够应用均摊时间复杂度分析的场合，一般均摊时间复杂度就等于最好情况时间复杂度。


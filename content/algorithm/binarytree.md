---
title: '二叉树'
date: 2024-07-05T12:53:00+08:00
params:
  math: true
---

## 树 (Tree)

![img.png](/images/algorithm/algo-binarytree-1.png)

这里面每个元素我们叫作“节点”；用来连线相邻节点之间的关系，我们叫作“父子关系”。

比如下面这幅图，A 节点就是 B 节点的父节点，B 节点是 A 节点的子节点。B、C、D 这三个节点的父节点是同一个节点，所以它们之间互称为兄弟节点。我们把没有父节点的节点叫作根节点，也就是图中的节点 E。我们把没有子节点的节点叫作叶子节点或者叶节点，比如图中的 G、H、I、J、K、L 都是叶子节点。

![img.png](/images/algorithm/algo-binarytree-2.png)

还有三个比较相似的概念：高度（Height）、深度（Depth）、层（Level）。它们的定义是这样的：

![img.png](/images/algorithm/algo-binarytree-3.png)

举例说明下：

![img.png](/images/algorithm/algo-binarytree-4.png)

## 二叉树 (Binary Tree)
二叉树，顾名思义，每个节点**最多有两个“叉”**，也就是两个子节点，分别是左子节点和右子节点。不过，二叉树并不要求每个节点都有两个子节点，有的节点只有左子节点，有的节点只有右子节点。

![img.png](/images/algorithm/algo-binarytree-5.png)

这个图里面，有两个比较特殊的二叉树，分别是编号 2 和编号 3 这两个。

其中，编号 2 的二叉树中，**叶子节点全都在最底层，除了叶子节点之外，每个节点都有左右两个子节点**，这种二叉树就叫作满二叉树。

编号 3 的二叉树中，**叶子节点都在最底下两层，最后一层的叶子节点都靠左排列，并且除了最后一层，其他层的节点个数都要达到最大**，这种二叉树叫作完全二叉树。

![img.png](/images/algorithm/algo-binarytree-6.png)


## 如何表示（或者存储）一棵二叉树？
想要存储一棵二叉树，我们有两种方法，一种是基于指针或者引用的**二叉链式存储法**，一种是基于数组的**顺序存储法**。

![img.png](/images/algorithm/algo-binarytree-7.png)

从上图中你应该可以很清楚地看到，每个节点有三个字段，其中一个存储数据，另外两个是指向左右子节点的指针。我们只要拎住根节点，就可以通过左右子节点的指针，把整棵树都串起来。这种存储方式我们比较常用。大部分二叉树代码都是通过这种结构来实现的。

![img.png](/images/algorithm/algo-binarytree-8.png)

基于数组的顺序存储法。我们把根节点存储在下标 i = 1 的位置，那左子节点存储在下标 2 * i = 2 的位置，右子节点存储在 2 * i + 1 = 3 的位置。以此类推，B 节点的左子节点存储在 2 * i = 2 * 2 = 4 的位置，右子节点存储在 2 * i + 1 = 2 * 2 + 1 = 5 的位置。

如果节点 X 存储在数组中下标为 i 的位置，下标为 2 * i 的位置存储的就是左子节点，下标为 2 * i + 1 的位置存储的就是右子节点。反过来，下标为 i/2 的位置存储就是它的父节点。通过这种方式，我们只要知道根节点存储的位置（**一般情况下，为了方便计算子节点，根节点会存储在下标为 1 的位置**），这样就可以通过下标计算，把整棵树都串起来。

不过，我刚刚举的例子是一棵完全二叉树，所以仅仅“浪费”了一个下标为 0 的存储位置。如果是非完全二叉树，其实会浪费比较多的数组存储空间。你可以看我举的下面这个例子。

![img.png](/images/algorithm/algo-binarytree-9.png)

所以，如果某棵二叉树是一棵**完全二叉树，那用数组存储无疑是最节省内存的一种方式**。因为数组的存储方式并不需要像链式存储法那样，要存储额外的左右子节点的指针。这也是为什么完全二叉树会单独拎出来的原因，也是为什么完全二叉树要求最后一层的子节点都靠左的原因。

## 二叉树的遍历
经典的方法有三种，**前序遍历、中序遍历和后序遍历**。其中，前、中、后序，表示的是节点与它的左右子树节点遍历打印的先后顺序。

前序遍历是指，对于树中的任意节点来说，先打印这个节点，然后再打印它的左子树，最后打印它的右子树。

中序遍历是指，对于树中的任意节点来说，先打印它的左子树，然后再打印它本身，最后打印它的右子树。

后序遍历是指，对于树中的任意节点来说，先打印它的左子树，然后再打印它的右子树，最后打印这个节点本身。

![img.png](/images/algorithm/algo-binarytree-10.png)

实际上，**二叉树的前、中、后序遍历就是一个递归的过程**。比如，前序遍历，其实就是先打印根节点，然后再递归地打印左子树，最后递归地打印右子树。

而写递推公式的关键就是，**如果要解决问题 A，就假设子问题 B、C 已经解决，然后再来看如何利用 B、C 来解决 A**。所以，我们可以把前、中、后序遍历的递推公式都写出来。

```text
前序遍历的递推公式：
preOrder(r) = print r->preOrder(r->left)->preOrder(r->right)

中序遍历的递推公式：
inOrder(r) = inOrder(r->left)->print r->inOrder(r->right)
```

```go
//TODO:CODE
```

从我前面画的前、中、后序遍历的顺序图，可以看出来，每个节点最多会被访问两次，所以遍历操作的时间复杂度，跟节点的个数 n 成正比，也就是说**二叉树遍历的时间复杂度是 O(n)**。

## 二叉查找树 (Binary Search Tree)
二叉查找树是二叉树中最常用的一种类型，也叫二叉搜索树。顾名思义，二叉查找树是为了实现快速查找而生的。不过，它不仅仅**支持快速查找一个数据，还支持快速插入、删除一个数据**。

**二叉查找树要求，在树中的任意一个节点，其左子树中的每个节点的值，都要小于这个节点的值，而右子树节点的值都大于这个节点的值**。

![img.png](/images/algorithm/algo-binarytree-11.png)

1. **二叉查找树的查找操作**

我们先取根节点，如果它等于我们要查找的数据，那就返回。如果要查找的数据比根节点的值小，那就在左子树中递归查找；如果要查找的数据比根节点的值大，那就在右子树中递归查找。

![img.png](/images/algorithm/algo-binarytree-12.png)

```go
//TODO:CODE
```

2. **二叉查找树的插入操作**

新插入的数据一般都是在叶子节点上，所以我们只需要从根节点开始，依次比较要插入的数据和节点的大小关系。

如果要插入的数据比节点的数据大，并且节点的右子树为空，就将新数据直接插到右子节点的位置；如果不为空，就再递归遍历右子树，查找插入位置。同理，如果要插入的数据比节点数值小，并且节点的左子树为空，就将新数据插入到左子节点的位置；如果不为空，就再递归遍历左子树，查找插入位置。

![img.png](/images/algorithm/algo-binarytree-13.png)

```go
//TODO:CODE
```

3. **二叉查找树的删除操作**

+ 第一种情况是，如果要删除的节点没有子节点，我们只需要直接将**父节点**中，**指向要删除节点的指针置为 null**。比如下图中的删除节点 55。
+ 第二种情况是，如果要删除的节点只有一个子节点（只有左子节点或者右子节点），我们只需要更新**父节点**中，指向要删除节点的指针，让它**指向要删除节点的子节点就可以了**。比如图中的删除节点 13。
+ 第三种情况是，如果要删除的节点有两个子节点，这就比较复杂了。我们需要找到**这个节点的右子树中的最小节点，把它替换到要删除的节点上**。然后再**删除掉这个最小节点**，因为**最小节点肯定没有左子节点**（如果有左子结点，那就不是最小节点了），所以，我们可以应用上面两条规则来删除这个最小节点。比如图中的删除节点 18。

![img.png](/images/algorithm/algo-binarytree-14.png)

```go
//TODO:CODE
```

实际上，关于二叉查找树的删除操作，还有个非常简单、取巧的方法，就是单纯将要删除的节点**标记为“已删除”**，但是并不真正从树中将这个节点去掉。这样原本删除的节点还需要存储在内存中，比较**浪费内存空间**，但是删除操作就变得简单了很多。而且，这种处理方法也并**没有增加插入、查找操作代码实现的难度**。

4. **二叉查找树的其他操作**

二叉查找树中还可以支持快速地查找最大节点和最小节点、前驱节点和后继节点。**中序遍历二叉查找树，可以输出有序的数据序列，时间复杂度是 O(n)，非常高效**。因此，二叉查找树也叫作**二叉排序树**。

```go
//TODO:CODE
```

## 支持重复数据的二叉查找树
前面讲二叉查找树的时候，我们默认树中节点存储的都是数字。很多时候，在实际的软件开发中，我们在**二叉查找树中存储的，是一个包含很多字段的对象。我们利用对象的某个字段作为键值（key）来构建二叉查找树**。我们把对象中的其他字段叫作卫星数据。

前面我们讲的二叉查找树的操作，针对的都是不存在键值相同的情况。那如果存储的两个对象键值相同，这种情况该怎么处理呢？

+ 二叉查找树中每一个节点不仅会存储一个数据，因此我们通过链表和支持动态扩容的数组等数据结构，**把值相同的数据都存储在同一个节点上**。
+ 每个节点仍然只存储一个数据。在查找插入位置的过程中，如果碰到一个节点的值，与要插入数据的值相同，我们就将这个要插入的数据放到这个节点的右子树，也就是说，**把这个新插入的数据当作大于这个节点的值来处理**。

![img.png](/images/algorithm/algo-binarytree-15.png)

**当要查找数据的时候，遇到值相同的节点，我们并不停止查找操作，而是继续在右子树中查找，直到遇到叶子节点，才停止**。这样就可以把键值等于要查找值的所有节点都找出来。

![img.png](/images/algorithm/algo-binarytree-16.png)

对于删除操作，我们也需要**先查找到每个要删除的节点**，然后再按前面讲的删除操作的方法，依次删除。

![img.png](/images/algorithm/algo-binarytree-17.png)

## 二叉查找树的时间复杂度分析

实际上，二叉查找树的形态各式各样。比如下图中，对于同一组数据，我们构造了三种二叉查找树。它们的查找、插入、删除操作的执行效率都是不一样的。图中第一种二叉查找树，根节点的左右子树极度不平衡，已经退化成了链表，所以查找的时间复杂度就变成了 O(n)。

![img.png](/images/algorithm/algo-binarytree-18.png)

我们现在来分析一个最理想的情况，二叉查找树是一棵完全二叉树（或满二叉树）。这个时候，插入、删除、查找的时间复杂度是多少呢？

**时间复杂度其实都跟树的高度成正比，也就是 O(height)**。既然这样，现在问题就转变成另外一个了，也就是，如何求一棵包含 n 个节点的完全二叉树的高度？

树的高度就等于最大层数减一，为了方便计算，我们转换成层来表示。包含 n 个节点的完全二叉树中，第一层包含 1 个节点，第二层包含 2 个节点，第三层包含 4 个节点，依次类推，下面一层节点个数是上一层的 2 倍，第 K 层包含的节点个数就是 $2^(K-1)$。

不过，对于完全二叉树来说，最后一层的节点个数有点儿不遵守上面的规律了。它包含的节点个数在 1 个到 $2^(L-1)$ 个之间（我们假设最大层数是 L）。如果我们把每一层的节点个数加起来就是总的节点个数 n。也就是说，如果节点的个数是 n，那么 n 满足这样一个关系：

```text
n >= 1+2+4+8+...+2^(L-2)+1
n <= 1+2+4+8+...+2^(L-2)+2^(L-1)
```

L 的范围是 [ $\log_2 (n+1)$, $\log_2 n +1$ ]。完全二叉树的层数小于等于 $\log_2 n +1$。也就是说，**完全二叉树的高度小于等于** $\log_2 n$。

显然，极度不平衡的二叉查找树，它的查找性能肯定不能满足我们的需求。我们需要构建一种不管怎么删除、插入数据，在任何时候，都能保持任意节点左右子树都比较平衡的二叉查找树。

## 思考
散列表的插入、删除、查找操作的时间复杂度可以做到常量级的 O(1)，非常高效。而二叉查找树在比较平衡的情况下，插入、删除、查找操作时间复杂度才是 O(logn)，相对散列表，好像并没有什么优势，那我们为什么还要用二叉查找树呢？

+ 第一，散列表中的数据是无序存储的，如果要输出有序的数据，需要先进行排序。而对于二叉查找树来说，我们只需要中序遍历，就可以在 O(n) 的时间复杂度内，输出有序的数据序列。
+ 第二，散列表扩容耗时很多，而且当遇到散列冲突时，性能不稳定，尽管二叉查找树的性能不稳定，但是在工程中，我们最常用的平衡二叉查找树的性能非常稳定，时间复杂度稳定在 O(logn)。
+ 第三，笼统地来说，尽管散列表的查找等操作的时间复杂度是常量级的，但因为哈希冲突的存在，这个常量不一定比 logn 小，所以实际的查找速度可能不一定比 O(logn) 快。加上哈希函数的耗时，也不一定就比平衡二叉查找树的效率高。
+ 第四，散列表的构造比二叉查找树要复杂，需要考虑的东西很多。比如散列函数的设计、冲突解决办法、扩容、缩容等。平衡二叉查找树只需要考虑平衡性这一个问题，而且这个问题的解决方案比较成熟、固定。最后，为了避免过多的散列冲突，散列表装载因子不能太大，特别是基于开放寻址法解决冲突的散列表，不然会浪费一定的存储空间。

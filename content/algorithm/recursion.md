---
title: '递归'
date: 2024-06-28T19:59:26+08:00
params:
  math: true
---

具体到一个现实的例子，在漆黑的电影院，你不知道当前你在哪一排。于是你就问前面一排的人他是第几排，你想只要在他的数字上加一，就知道自己在哪一排了。但是，前面的人也看不清啊，所以他也问他前面的人。就这样一排一排往前问，直到问到第一排的人，说我在第一排，然后再这样一排一排再把数字传回来。直到你前面的人告诉你他在哪一排，于是你就知道答案了。

这就是一个非常标准的递归求解问题的分解过程，去的过程叫“递”，回来的过程叫“归”。基本上，所有的递归问题都可以用递推公式来表示。刚刚这个生活中的例子，我们用递推公式将它表示出来就是这样的： $f(n)=f(n-1)+1$，其中 f(1) = 1。

```c
int f(int n) {  
    if (n == 1) return 1;
    return f(n-1) + 1;
}
```

## 递归需要满足的三个条件
1. 一个问题的解可以分解为几个子问题的解：子问题就是数据规模更小的问题。比如，前面讲的电影院的例子，你要知道，“自己在哪一排”的问题，可以分解为“前一排的人在哪一排”这样一个子问题。
2. 这个问题与分解之后的子问题，除了数据规模不同，求解思路完全一样。
3. 存在递归终止条件：把问题分解为子问题，把子问题再分解为子子问题，一层一层分解下去，不能存在无限循环，这就需要有终止条件。比如前面的问题，f(1)=1 就是递归的终止条件。

写递归代码最关键的是**写出递推公式，找到终止条件**。

假如这里有n个台阶，每次你可以跨1个台阶或者2个台阶，请问走这n个台阶有多少种走法？如果有7个台阶，你可以2，2，2，1这样子上去，也可以1，2，1，1，2这样子上去，总之走法有很多，那如何用编程求得总共有多少种走法呢？

实际上，可以根据第一步的走法把所有走法分为两类，第一类是第一步走了1个台阶，另一类是第一步走了2个台阶。所以**n个台阶的走法就等于先走1阶后，n-1个台阶的走法加上先走2阶后，n-2个台阶的走法**。用公式表示就是：$f(n)=f(n-1)+f(n-2)$

有了递归公式，最重要的就是找到终止条件。当有一个台阶时，我们不需要再继续递归，就只有一种走法。所以f(1)=1。当n=2时，f(2)=f(1)+f(0)。如果递归终止条件只有一个f(1)=1，那f(2)就无法求解了。所以除了f(1)=1这一个递归终止条件外，还要有f(0)=1，表示走0个台阶有一种走法，不过这样子看起来就不符合正常的逻辑思维了。所以，我们可以把f(2)=2作为一种终止条件，表示走2个台阶，有两种走法，一步走完或者分两步来走。

所以，递归终止条件就是f(1)=1，f(2)=2。这个时候，你可以再拿n=3，n=4来验证一下，这个终止条件是否足够并且正确。于是：

```c
int f(int n) {
    if (n == 1) return 1;
    if (n == 2) return 2;
    return f(n-1) + f(n-2);
}
```

如果一个问题A可以分解为若干子问题B、C、D，你可以**假设子问题B、C、D已经解决**，在此基础上思考如何解决问题A。而且，你只需要思考问题A与子问题B、C、D两层之间的关系即可，不需要一层一层往下思考子问题与子子问题，子子问题与子子子问题之间的关系。**屏蔽掉递归细节**，这样子理解起来就简单多了。

## 递归代码注意事项
+ 递归代码要警惕堆栈溢出
+ 递归代码要警惕重复计算

![img.png](/images/algorithm/algo-recursion-1.png)

从上图中，我们可以直观地看到，想要计算 f(5)，需要先计算 f(4) 和 f(3)，而计算 f(4) 还需要计算 f(3)，因此，f(3) 就被计算了很多次，这就是重复计算问题。

为了避免重复计算，我们可以通过一个数据结构（比如散列表）来保存已经求解过的 f(k)。当递归调用到 f(k) 时，先看下是否已经求解过了。如果是，则直接从散列表中取值返回，不需要重复计算，这样就能避免刚讲的问题了。

在时间效率上，递归代码里多了很多函数调用，当这些函数调用的数量较大时，就会积聚成一个可观的时间成本。在空间复杂度上，因为递归调用一次就会在内存栈中保存一次现场数据，所以在分析递归代码空间复杂度时，需要额外考虑这部分的开销，比如我们前面讲到的电影院递归代码，空间复杂度并不是 O(1)，而是 O(n)。

## 怎么将递归代码改写为非递归代码？
递归有利有弊，利是递归代码的表达力很强，写起来非常简洁；而弊就是空间复杂度高、有堆栈溢出的风险、存在重复计算、过多的函数调用会耗时较多等问题。

f(n) = f(n-1) +1 

```c
int f(int n) {
    int ret = 1;
    for (int i = 2; i <= n; ++i) {
        ret = ret + 1;
    }
    return ret;
}
```

f(n) = f(n-1) + f(n-2)

```c
int f(int n) {
    if (n == 1) return 1;
    if (n == 2) return 2;
  
    int ret = 0;
    int pre = 2;
    int prepre = 1;
    for (int i = 3; i <= n; ++i) {
        ret = pre + prepre;
        prepre = pre;
        pre = ret;
    }
     return ret;
}
```

那是不是所有的递归代码都可以改为这种迭代循环的非递归写法呢？

笼统地讲，是的。因为**递归本身就是借助栈来实现的**，只不过我们使用的栈是系统或者虚拟机本身提供的，我们没有感知罢了。**如果我们自己在内存堆上实现栈，手动模拟入栈、出栈过程，这样任何递归代码都可以改写成看上去不是递归代码的样子**。

> TODO: 尝试模拟栈解决一个递归问题

但是这种思路**实际上是将递归改为了“手动”递归，本质并没有变**，而且也并没有解决前面讲到的某些问题，徒增了实现的复杂度。
